Разработать модульный Telegram UserBot, состоящий из backend‑сервиса на FastAPI и frontend‑приложения (SPA) с визуальным редактором «диалоговых цепочек» (подобно ментальным картам). Бот должен работать на Telethon и обеспечивать многозадачность, асинхронность и возможность распараллеливания (многопоточность/мультипроцессинг).


Архитектура
• Backend: FastAPI, Python 3.10+
– Telethon для работы с Telegram API
– SQLAlchemy + asyncpg для PostgreSQL (хранение сессий, настроек, данных цепочек)
– Modular plugin system: автозагрузка/разгрузка модулей без перезапуска (watch‑folder или динамический импорт)
– Celery/Prefect/RQ или встроенный asyncio‑scheduler для фоновых задач и параллельной обработки
– WebSocket‑канал (FastAPI WebSockets) для пушей в frontend (статусы задач, логи)
• Frontend: Vue 3 / React / Svelte (на выбор)
– SPA с drag‑and‑drop визуальным редактором «узлы + связи»
– Каждый узел — это блок с условиями (if/else), задержками, API‑запросами, пользовательскими сценариями
– Настройки узлов: ввод текста, выбор действий, подключение внешних модулей через UI
– Панель плагинов: встраиваемые виджеты или SDK‑модули, загружаемые динамически
– Работа с WebSocket для отображения логов и статусов исполнения в реальном времени


Основные требования
• Диалоговые цепочки:
– Визуальный граф редактирования: создание узлов, соединение стрелками, настройка переходов по условиям
– Сохранение/загрузка цепочек в БД и экспорт/импорт (JSON/YAML)
– Версионирование цепочек
• Пользовательский интерфейс должен быть интуитивным и не требовать знаний кодирования
• Plugin API для расширения функциональности:
– Регистрация команд, горячих клавиш, новых типов узлов
– Хуки до/после обработки сообщений
– Автоматическая документация плагинов на Swagger/UI
• Асинхронность и распараллеливание:
– Обработка нескольких цепочек/сессий одновременно
– Перенос тяжёлых вычислений в background‑workers
• Безопасность и масштабируемость:
– OAuth2/JWT для аутентификации API и Web UI
– Настройка прав доступа к отдельным бот‑сессиям и цепочкам
– Docker‑ready, окружения dev/prod, CI/CD


Детали реализации
• Сущности БД (пример):
– User (id, email, hashed_password)
– BotSession (id, session_string, owner_id, status)
– DialogueChain (id, name, version, graph_json, owner_id, created_at)
– Task (id, chain_id, node_id, status, started_at, finished_at, log)
• API-endpoints (FastAPI):
– /auth/login, /auth/register, /auth/refresh
– /sessions/* CRUD для Telegram‑сессий
– /chains/* CRUD + экспорт/импорт
– /tasks/* запуск/остановка/статус
– /plugins/* управление плагинами
• Frontend:
– Страница входа/регистрации
– Дашборд с обзором сессий и цепочек
– Редактор диалогов: palette узлов, canvas, sidebar для настроек
– Логи запуска и мониторинг карьерного исполнения в реальном времени


Ожидаемый результат
• Готовый репозиторий с модульным Python‑backend и SPA‑frontend
• Документация по развертыванию (docker‑compose, env‑файлы) и по написанию плагинов
• Тесты (unit + integration) для основных API и ядра бота
• Демонстрационный бот‑сценарий в виде цепочки «приветствие → проверка условий → ответ пользователю»


ТОЛЬКО РАБОЧИЙ PRODUCTION-READY КОД!
Никаких моков, заглушек, фейковых данных, симуляций или временных решений.
1. Запрещается использовать: demo, mock, fake, simulate, stub, placeholder, dummy
2. Math.random(), setTimeout() для имитации ответа
3. Фиктивные структуры, фейковые данные, временные модули
Требования:
1. Использовать реальные API, реальные источники данных, реальные зависимости
2. Все модули, классы и функции должны быть полностью работоспособны
3. При отсутствии данных — создавай реальные интерфейсы и подключения, не заполняй фиктивными значениями
4. Взаимодействие с БД, сетью, файловой системой должно быть реальным
5. Цель: 100% боевой код, готовый к внедрению в продакшен, без временных решений.
ПИШИ ПОЖАЛУЙСТА НА РУССКОМ ЯЗЫКЕ, СПАСИБО!
